HypergraphGo — HoTT Kernel Roadmap To-Do

# Conventions
# [ ] task
# Indentation indicates sub-tasks.
# “Done when” are crisp acceptance criteria.

============================================================
PHASE 0 — Ground rules and interfaces
============================================================
[X] Decide core theory profile
    [X] Choose: Cubical (with Path/Interval) or Id-type first, then flip later
    [X] Universe policy: cumulative vs lifts; write a short DESIGN.md
    [X] Normalization strategy: NbE (document reify/reflect invariants)
    [X] Binding: de Bruijn indices for core; raw names for surface
    Done when: DESIGN.md exists and commits pin these decisions.

[X] Define public kernel boundary
    [X] Package layout: ast, syntax, core, eval, check, env, kernel, elab, cmd/hottgo
    [X] Kernel API: {Axiom, Def, Inductive, (later) HIT, Theorem} only
    Done when: kernel compiles and exports a minimal, documented interface.

============================================================
PHASE 1 — Syntax, binding, pretty printing
============================================================
[X] Core AST (de Bruijn)
    [X] Terms: Var, Sort(u), Pi, Lam, App, Sigma, Pair, Fst, Snd, Let, Global
    [X] Base data: Nat/zero/succ; Bool/true/false (placeholders)
    Done when: go test round-trips simple terms.

[X] Raw AST + name resolution
    [X] Raw with identifiers; scope resolver to core AST (de Bruijn)
    Done when: alpha-equal terms print the same under pretty-printer.

[ ] Parser + printer (minimal concrete syntax or S-expr)
    Done when: parse(print(t)) == t for a small corpus (golden tests).

============================================================
PHASE 2 — Normalization and definitional equality
============================================================
[ ] NbE skeleton
    [ ] Semantic domain (closures), reify/reflect
    [ ] WHNF, spine application
    Done when: (\x. x) y normalizes to y; projections normalize.

[ ] Definitional equality via NbE
    [ ] Conversion checker with optional η for Π/Σ
    Done when: β/η tests pass; microbench under target latency.

============================================================
PHASE 3 — Bidirectional type checking
============================================================
[ ] Bidirectional rules
    [ ] Γ ⊢ t ⇒ A, Γ ⊢ t ⇐ A for Π, Σ, Sorts, Nat, Bool
    [ ] Implicit inference stays outside kernel (elab)
    Done when: id : Π(A:Type). A → A checks; precise errors on ill-typed apps.

[ ] Global environment
    [ ] Persistent store: constants with types/defs; opaque/transparent flags
    Done when: simple Def/opaque works; unfolding controlled by flags.

============================================================
PHASE 4 — Identity/Path types (and cubical knob)
============================================================
[ ] Id/J (baseline) OR Cubical Path
    [ ] If Id: intro refl; elim J with computation rule
    [ ] If Cubical: Interval I, endpoints 0/1; Path abstraction/application
    [ ] Composition/filling ops if cubical
    Done when: path induction reduces; funext derivable if cubical.

============================================================
PHASE 5 — Inductives, recursors, positivity
============================================================
[ ] Positivity checker (strictly positive)
    Done when: rejects T = T -> T; accepts List, Vec.

[ ] Inductive schema (parameters/indices)
    [ ] Auto-generated eliminators with β-rules
    Done when: Nat, List, Vec compile; map/rec compute by definitional equality.

[ ] Universe-polymorphic inductives
    Done when: List at Type u works across levels or via explicit lifts.

============================================================
PHASE 6 — Univalence
============================================================
[ ] Choose approach
    [ ] Axiom: ua : Equiv A B → Path (Type u) A B
    [ ] OR Cubical: Glue types so transport computes
    Done when: transport across equivalence reduces on records (test proof).

============================================================
PHASE 7 — Higher Inductive Types (HITs)
============================================================
[ ] HIT support MVP
    [ ] Hard-code S¹ (base, loop) with eliminator; computation rules
    [ ] Optionally add pushout or suspension
    Done when: recursor for S¹ computes on base/loop as specified.

============================================================
PHASE 8 — Elaboration and tactics (untrusted)
============================================================
[ ] Elaborator conveniences
    [ ] Implicit args, holes, simple metavars, pattern matching → eliminators
    Done when: sugar expands to core; kernel re-checks expanded terms.

[ ] Micro-tactics (outside kernel)
    [ ] refine, intro, exact, rewrite (by path), solve simple goals
    Done when: short proofs script and re-check; no kernel API creep.

============================================================
PHASE 9 — Standard library seed
============================================================
[ ] Path algebra
    [ ] concat, inverse, whiskering; groupoid laws up to paths
    Done when: library compiles; tests verify laws.

[ ] Equivalences and h-levels
    [ ] Equiv, isContr, isProp, isSet; truncations API
    Done when: basic lemmas available; transport helpers land.

[ ] Data library
    [ ] Fin, Option, Sum, Product, List, Vec utilities
    Done when: map/fold/fusion lemmas pass conversion-based tests.

============================================================
PHASE 10 — Performance, soundness, packaging
============================================================
[ ] Benchmarks
    [ ] conv/elab benches; hash-consing for convertibility cache
    Done when: stable numbers and flamegraphs checked in /bench.

[ ] Soundness guardrails
    [ ] Small-step reference checker for subset; fuzz raw→elab→check pipeline
    Done when: zero panics; all accepted terms have explicit types.

[ ] CLI tooling
    [ ] cmd/hottgo: check files, show goals, JSON protocol
    Done when: hottgo check examples/*.hottgo returns green or clear errors.

============================================================
MILESTONE TASKS (bite-sized, commit-by-commit)
============================================================
[ ] M1: Introduce core Term + Level types (ast)
    Done when: build λx. x; pretty-print "\x => x".

[ ] M2: Context/env utilities (ctx, env)
    Done when: out-of-scope variables rejected; globals resolved.

[ ] M3: NbE skeleton (eval)
    Done when: beta for apps and projections normalize.

[ ] M4: Defeq via NbE (core.Conv)
    Done when: η for functions behind a feature flag passes.

[ ] M5: Bidirectional checker (check.Synth/Check)
    Done when: id and compose typecheck; precise spans on errors.

[ ] M6: Naturals + recursor
    Done when: plus definitional equalities for small numerals.

[ ] M7: Identity/Path rules
    Done when: J/path induction reduces; funext proof if cubical.

[ ] M8: Universes
    Done when: Type u : Type (u+1); no Type : Type.

[ ] M9: Inductives MVP
    Done when: List map fusion holds; positivity rejects bad defs.

[ ] M10: Univalence (axiom or glue)
    Done when: transport across equivalence computes in a demo.

[ ] M11: HIT S¹
    Done when: eliminator computes on base/loop as specified.

[ ] M12: Elaborator sugar
    Done when: implicit args and pattern matching expand and re-check.

[ ] M13: CLI + golden tests
    Done when: “hottgo check” on examples passes; golden outputs stable.

[ ] M14: Perf + fuzz
    Done when: 1h fuzz run finds no panics; memory monotone.

============================================================
REPO HYGIENE
============================================================
[ ] Kernel fence
    Done when: kernel has no non-std imports and never panics.

[ ] Golden tests
    Done when: pretty-printed NFs and error messages are golden-filed.

[ ] Deterministic errors
    Done when: error messages are stable across runs (sorted maps, etc).

[ ] CI
    Done when: go test ./... and examples run in CI; benches in separate job.

[ ] Docs
    Done when: DESIGN.md with all rules you actually implement; any unwritten rule is considered non-existent.

============================================================
EXAMPLES & TEST CORPUS
============================================================
[ ] examples/core.hottgo: id, compose, pair/fst/snd, Nat recursor
[ ] examples/paths.hottgo: concat/inv laws up to path
[ ] examples/equiv.hottgo: simple equivalence and transport demo
[ ] examples/s1.hottgo: circle eliminator test (once HITs land)
Done when: all examples pass “hottgo check”.
